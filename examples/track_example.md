# goat track Usage Example

[中文版](zh-cn/track_example.md)

This example demonstrates how to use the `goat track` command to track code changes and automatically insert tracing code.

## Scenario Description

We have a simple calculator application and now need to add a new feature: calculating the power of two numbers. We want to use goat to track the execution of this new feature.

## Original Code

The following is the original calculator code (`calculator/main.go`):

```go
package main

import (
	"fmt"
	"os"
	"strconv"
)

// Calculator provides basic arithmetic operations
type Calculator struct{}

// Add returns the sum of two numbers
func (c *Calculator) Add(a, b int) int {
	return a + b
}

// Subtract returns the difference of two numbers
func (c *Calculator) Subtract(a, b int) int {
	return a - b
}

// Multiply returns the product of two numbers
func (c *Calculator) Multiply(a, b int) int {
	return a * b
}

// Divide returns the quotient of two numbers
func (c *Calculator) Divide(a, b int) int {
	if b == 0 {
		fmt.Println("Error: Division by zero")
		return 0
	}
	return a / b
}

func main() {
	if len(os.Args) != 4 {
		fmt.Println("Usage: calculator <operation> <num1> <num2>")
		fmt.Println("Operations: add, subtract, multiply, divide")
		os.Exit(1)
	}

	operation := os.Args[1]
	num1, err1 := strconv.Atoi(os.Args[2])
	num2, err2 := strconv.Atoi(os.Args[3])

	if err1 != nil || err2 != nil {
		fmt.Println("Error: Arguments must be integers")
		os.Exit(1)
	}

	calc := &Calculator{}
	var result int

	switch operation {
	case "add":
		result = calc.Add(num1, num2)
	case "subtract":
		result = calc.Subtract(num1, num2)
	case "multiply":
		result = calc.Multiply(num1, num2)
	case "divide":
		result = calc.Divide(num1, num2)
	default:
		fmt.Println("Error: Invalid operation")
		os.Exit(1)
	}

	fmt.Printf("Result: %d\n", result)
}
```

## Step 1: Initialize the Git repository and commit the original code

```bash
# Enter the sample project directory
cd calculator

# Initialize the Git repository
git init

# Add all files
git add.

# Commit the original version
git commit -m "Initial commit with basic calculator functionality"

# Create the main branch (as the stable branch)
git branch -M main
```

## Step 2: Create a new branch and add new functionality

```bash
# Create and switch to a new branch
git checkout -b feature/power-function

# Modify the code in the editor to add the Power functionality
```

The modified code (with the new Power method added and the main function updated):

```go
package main

import (
	"fmt"
	"math"
	"os"
	"strconv"
)

// Calculator provides basic arithmetic operations
type Calculator struct{}

// Add returns the sum of two numbers
func (c *Calculator) Add(a, b int) int {
	return a + b
}

// Subtract returns the difference of two numbers
func (c *Calculator) Subtract(a, b int) int {
	return a - b
}

// Multiply returns the product of two numbers
func (c *Calculator) Multiply(a, b int) int {
	return a * b
}

// Divide returns the quotient of two numbers
func (c *Calculator) Divide(a, b int) int {
	if b == 0 {
		fmt.Println("Error: Division by zero")
		return 0
	}
	return a / b
}

// Power returns a raised to the power of b
func (c *Calculator) Power(a, b int) int {
	return int(math.Pow(float64(a), float64(b)))
}

func main() {
	if len(os.Args) != 4 {
		fmt.Println("Usage: calculator <operation> <num1> <num2>")
		fmt.Println("Operations: add, subtract, multiply, divide, power")
		os.Exit(1)
	}

	operation := os.Args[1]
	num1, err1 := strconv.Atoi(os.Args[2])
	num2, err2 := strconv.Atoi(os.Args[3])

	if err1 != nil || err2 != nil {
		fmt.Println("Error: Arguments must be integers")
		os.Exit(1)
	}

	calc := &Calculator{}
	var result int

	switch operation {
	case "add":
		result = calc.Add(num1, num2)
	case "subtract":
		result = calc.Subtract(num1, num2)
	case "multiply":
		result = calc.Multiply(num1, num2)
	case "divide":
		result = calc.Divide(num1, num2)
	case "power":
		result = calc.Power(num1, num2)
	default:
		fmt.Println("Error: Invalid operation")
		os.Exit(1)
	}

	fmt.Printf("Result: %d\n", result)
}
```
Submit new feature:

```bash
# Commit the changes
git add.
git commit -m "Add power function to calculator"
```

## Step 3: Initialize the goat configuration

```bash
# Initialize the goat configuration
goat init --old main --new feature/power-function --app-name "calculator" --granularity patch
```

This will generate a `goat.yaml` configuration file in the root directory of the project, with content similar to:

```yaml
# Goat configuration goat.yaml
#
# This file is generated by goat.
# Please do modify when you know what you are doing.
# Every time the field is changed, please rerun "goat patch" to update the tracking results.
#
## App name
appName: calculator

## App version
appVersion: 1.0.0

## Old branch name (for comparison base)
oldBranch: main

## New branch name (for comparison target)
newBranch: feature/power-function

## Granularity ([line, patch, scope, func], default: patch)
granularity: patch

# ... other setting
```

## Step 4: Run the goat track command to insert the tracking code

```bash
# Run the goat track command
goat track
```

Example of command output:

```
[2025/04/23 22:17:28] INFO: Start to run track command
[2025/04/23 22:17:28] INFO: Track applied successfully with 2 tracking points
[2025/04/23 22:17:28] INFO: ----------------------------------------------------------
[2025/04/23 22:17:28] INFO: ✅ Track completed successfully!
```

## Step 5: Check the inserted tracking code

After running goat track, the tracking code will be automatically inserted into the code. Check the modified file:

```bash
# Check the changes
git diff
```

Example output (you can see the tracking code inserted by goat):

```diff
diff --git a/main.go b/main.go
index 041bd3c..96519bb 100644
--- a/main.go
+++ b/main.go
@@ -6,6 +6,7 @@ import (
 	"os"
 	"os/signal"
 	"strconv"
+	goat "calculator/goat"
 )

 // Calculator provides basic arithmetic operations
@@ -37,10 +38,18 @@ func (c *Calculator) Divide(a, b int) int {

 // Power returns a raised to the power of b
 func (c *Calculator) Power(a, b int) int {
+	// +goat:generate
+	// +goat:tips: do not edit the block between the +goat comments
+	goat.Track(goat.TRACK_ID_1)
+	// +goat:end
 	return int(math.Pow(float64(a), float64(b)))
 }

 func main() {
+	// +goat:main
+	// +goat:tips: do not edit the block between the +goat comments
+	goat.ServeHTTP(goat.COMPONENT_0)
+	// +goat:end
 	if len(os.Args) != 4 {
 		fmt.Println("Usage: calculator <operation> <num1> <num2>")
 		fmt.Println("Operations: add, subtract, multiply, divide")
@@ -69,6 +78,10 @@ func main() {
 	case "divide":
 		result = calc.Divide(num1, num2)
 	case "power":
+		// +goat:generate
+		// +goat:tips: do not edit the block between the +goat comments
+		goat.Track(goat.TRACK_ID_2)
+		// +goat:end
 		result = calc.Power(num1, num2)
 	default:
 		fmt.Println("Error: Invalid operation")

```

```bash
  # View the modified code
  cat main.go
```

The modified main.go

```go
package main

import (
	"fmt"
	"math"
	"os"
	"os/signal"
	"strconv"
	goat "calculator/goat"
)

// Calculator provides basic arithmetic operations
type Calculator struct{}

// Add returns the sum of two numbers
func (c *Calculator) Add(a, b int) int {
	return a + b
}

// Subtract returns the difference of two numbers
func (c *Calculator) Subtract(a, b int) int {
	return a - b
}

// Multiply returns the product of two numbers
func (c *Calculator) Multiply(a, b int) int {
	return a * b
}

// Divide returns the quotient of two numbers
func (c *Calculator) Divide(a, b int) int {
	if b == 0 {
		fmt.Println("Error: Division by zero")
		return 0
	}
	return a / b
}

// Power returns a raised to the power of b
func (c *Calculator) Power(a, b int) int {
	// +goat:generate
	// +goat:tips: do not edit the block between the +goat comments
	goat.Track(goat.TRACK_ID_1)
	// +goat:end
	return int(math.Pow(float64(a), float64(b)))
}

func main() {
	// +goat:main
	// +goat:tips: do not edit the block between the +goat comments
	goat.ServeHTTP(goat.COMPONENT_0)
	// +goat:end
	if len(os.Args) != 4 {
		fmt.Println("Usage: calculator <operation> <num1> <num2>")
		fmt.Println("Operations: add, subtract, multiply, divide")
		os.Exit(1)
	}

	operation := os.Args[1]
	num1, err1 := strconv.Atoi(os.Args[2])
	num2, err2 := strconv.Atoi(os.Args[3])

	if err1 != nil || err2 != nil {
		fmt.Println("Error: Arguments must be integers")
		os.Exit(1)
	}

	calc := &Calculator{}
	var result int

	switch operation {
	case "add":
		result = calc.Add(num1, num2)
	case "subtract":
		result = calc.Subtract(num1, num2)
	case "multiply":
		result = calc.Multiply(num1, num2)
	case "divide":
		result = calc.Divide(num1, num2)
	case "power":
		// +goat:generate
		// +goat:tips: do not edit the block between the +goat comments
		goat.Track(goat.TRACK_ID_2)
		// +goat:end
		result = calc.Power(num1, num2)
	default:
		fmt.Println("Error: Invalid operation")
	}

	fmt.Printf("Result: %d\n", result)
	fmt.Println("Click http://localhost:57005/metrics to see the metrics")
	fmt.Println("Ctrl+C to stop the calculator")
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt)
	<-sigChan
	fmt.Println("Calculator stopped")
}

```


```bash
# View goat/goat_generated.go
cat goat/goat_generated.go
```
The content of goat/goat_generated.go is as follows:

```go
// +goat: generated by increment tracking package, do not edit
package goat

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"sort"
	"strconv"
	"strings"
)

// application version
const VERSION = "1.0.0"
// application name
const NAME = "calculator"
// track ID type
type trackId = int
// track ID values
const (
	// track ID start value
	TRACK_ID_START = iota
	TRACK_ID_1
	TRACK_ID_2
	// ...
	// track ID end value
	TRACK_ID_END
)

// track ID names
var TrackIdNames [TRACK_ID_END]string

// track ID status record - use slice instead of map to improve performance
var trackIdStatus [TRACK_ID_END]uint32

// initialize track IDs
func init() {
	for i := 1; i < TRACK_ID_END; i++ {
		TrackIdNames[i] = fmt.Sprintf("TRACK_ID_%d", i)
	}
}

// Track track function
func Track(id trackId) {
	if id > 0 && id < TRACK_ID_END {
		trackIdStatus[id] = 1
	}
}

// Component type
type Component = int

// Component IDs
const (
	_           = iota - 1
	COMPONENT_0 // 0
	// ...
)

// Components slice
var components = []Component{
	COMPONENT_0,
	// ...
}
// Component names
var componentNames = []string{
	COMPONENT_0: ".",
	// ...
}
// Component names map
var componentNamesMap = map[string]Component{
	".": COMPONENT_0,
	// ...
}
// GetComponentName get component name
func GetComponentName(component Component) string {
	return componentNames[component]
}

// Track IDs for component 0
var COMPONENT_0_TRACK_IDS = []trackId{
	TRACK_ID_1,
	TRACK_ID_2,
	// ...
}

// Component to track ID mapping
var COMPONENT_TRACK_IDS = map[Component][]trackId{
	COMPONENT_0: COMPONENT_0_TRACK_IDS,
	// ...
}

// Item struct
type Item struct {
	// track ID
	ID int `json:"id"`
	// track name
	Name string `json:"name"`
	// track count
	Count uint32 `json:"count"`
}

// Items slice
type Items []Item

// Metrics struct
type Metrics struct {
	// total track count
	Total       int    `json:"total"`
	// covered track count
	Covered     int    `json:"covered"`
	// covered rate
	CoveredRate int    `json:"coveredRate"`
	// track items
	Items       Items  `json:"items"`
}

// ComponentResult struct
type ComponentResult struct {
	// component
	ID Component `json:"id"`
	// component name
	Name string `json:"name"`
	// metrics
	Metrics   Metrics   `json:"metrics"`
}
// Results struct
type Results struct {
	// name
	Name string `json:"name"`
	// version
	Version string `json:"version"`
	// results
	Results []ComponentResult `json:"results"`
}
// ServeHTTP start HTTP service
func ServeHTTP(component Component) {
	go func() {
		system := http.NewServeMux()
		system.HandleFunc("/metrics", metricsHandler)
  		// DEAD in hexadecimal is 57005 in decimal
		port := "57005"
		if os.Getenv("GOAT_PORT") != "" {
			port = os.Getenv("GOAT_PORT")
		}
		expose := os.Getenv("GOAT_METRICS_IP")
		if expose == "" {
			expose = "127.0.0.1"
		}
		addr := fmt.Sprintf("%s:%s", expose, port)
		log.Printf("Goat track service started: http://%s\n", addr)
		// Tips how to use
		log.Printf("Goat track all components: http://%s/metrics\n", addr)
		log.Printf("Goat track component: http://%s/metrics?component=COMPONENT_ID\n", addr)
		log.Printf("Goat track components: http://%s/metrics?component=COMPONENT_ID,COMPONENT_ID2\n", addr)
		log.Printf("Goat track order by count asc: http://%s/metrics?component=COMPONENT_ID&order=0\n", addr)
		log.Printf("Goat track order by count desc: http://%s/metrics?component=COMPONENT_ID&order=1\n", addr)
		log.Printf("Goat track order by id asc: http://%s/metrics?component=COMPONENT_ID&order=2\n", addr)
		log.Printf("Goat track order by id desc: http://%s/metrics?component=COMPONENT_ID&order=3\n", addr)
		log.Fatal(http.ListenAndServe(addr, system))
	}()
}

// metricsHandler track ID status processing function
func metricsHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	// invalid order:
	// order=0: count asc (default)
	// order=1: count desc
	// order=2: id asc
	// order=3: id desc
	orderStr := r.URL.Query().Get("order")
	order, err := strconv.Atoi(orderStr)
	if err != nil || order < 0 || order > 3 {
		order = 0
	}
	cms := components
	componentStr := r.URL.Query().Get("component")
	if componentStr != "" {
		componentSlice := strings.Split(componentStr, ",")
		cms = make([]Component, 0, len(componentSlice))
		for _, componentStr := range componentSlice {
			componentIdx, ok := componentNamesMap[componentStr]
			if !ok {
				// check if it is a number
				componentIdx, err := strconv.Atoi(componentStr)
				if err != nil || componentIdx < 0 || componentIdx >= len(components) {
					http.Error(w, "invalid component", http.StatusBadRequest)
					return
				}
				cms = append(cms, Component(componentIdx))
				continue
			}
			cms = append(cms, componentIdx)
		}
	}

	results := make([]ComponentResult, 0, len(cms))
	for _, component := range cms {
		covered := 0
		componentTrackIds := COMPONENT_TRACK_IDS[component]
		items := make(Items, 0, len(componentTrackIds))
		for _, id := range componentTrackIds {
			count := trackIdStatus[id]
			items = append(items, Item{ID: id, Name: TrackIdNames[id], Count: count})
			if count > 0 {
				covered++
			}
		}

		switch order {
		case 0:
			sort.Slice(items, func(i, j int) bool {
				return items[i].Count < items[j].Count
			})
		case 1:
			sort.Slice(items, func(i, j int) bool {
				return items[i].Count > items[j].Count
			})
		case 2:
			sort.Slice(items, func(i, j int) bool {
				return items[i].ID < items[j].ID
			})
		case 3:
			sort.Slice(items, func(i, j int) bool {
				return items[i].ID > items[j].ID
			})
		}
		coveredRate := 0
		if len(componentTrackIds) > 0 {
			coveredRate = covered * 100 / len(componentTrackIds)
		}
		results = append(results, ComponentResult{
			ID:      component,
			Name:    GetComponentName(component),
			Metrics: Metrics{Total: len(componentTrackIds), Covered: covered, CoveredRate: coveredRate, Items: items},
		})
	}
	// output JSON
	jsonData, _ := json.Marshal(Results{Name: NAME, Version: VERSION, Results: results})
	w.Write(jsonData)
}


```

## Step 6: Build and Run the Application

Compile and run the program:

```bash
# Compile the program
go build -o calculator

# Run the program to calculate 2 to the power of 3
./calculator power 2 3
```

Example output:

```
Result: 8
Click http://localhost:57005/metrics to see the metrics
Ctrl+C to stop the calculator
```

## Step 7: View Tracking Data

When the application is running, goat will automatically start an HTTP service (default port 57005) to display the coverage of data points:

```bash
# Use curl to query the status of data points
curl http://localhost:57005/metrics | jq
```

Example output:

```json
{
  "name": "calculator",
  "version": "1.0.0",
  "results": [
    {
      "id": 0,
      "name": ".",
      "metrics": {
        "total": 2,
        "covered": 2,
        "coveredRate": 100,
        "items": [
          {
            "id": 1,
            "name": "TRACK_ID_1",
            "count": 1
          },
          {
            "id": 2,
            "name": "TRACK_ID_2",
            "count": 1
          }
        ]
      }
    }
  ]
}
```

## Summary

Through this example, we demonstrated how to use the `goat track` command to achieve the following functions:

1. Automatically identify code changes (newly added Power features)
2. Automatically insert tracking code
3. Collect data on the execution of buried points at runtime
4. View the coverage of buried points through an HTTP interface

This tracking method is very useful in gray release, which can help developers confirm whether new features are correctly called and executed in the production environment.
