# goat track 使用示例

[English](../track_example.md)

本示例演示如何使用 `goat track` 命令跟踪代码变更并自动插入跟踪代码。

## 场景描述

我们有一个简单的计算器应用程序，现在需要添加一个新功能：计算两个数字的幂运算。我们希望使用 goat 跟踪这个新功能的执行情况。

## 原始代码

以下是原始计算器代码（`calculator/main.go`）：

```go
package main

import (
	"fmt"
	"os"
	"strconv"
)

// Calculator provides basic arithmetic operations
type Calculator struct{}

// Add returns the sum of two numbers
func (c *Calculator) Add(a, b int) int {
	return a + b
}

// Subtract returns the difference of two numbers
func (c *Calculator) Subtract(a, b int) int {
	return a - b
}

// Multiply returns the product of two numbers
func (c *Calculator) Multiply(a, b int) int {
	return a * b
}

// Divide returns the quotient of two numbers
func (c *Calculator) Divide(a, b int) int {
	if b == 0 {
		fmt.Println("Error: Division by zero")
		return 0
	}
	return a / b
}

func main() {
	if len(os.Args) != 4 {
		fmt.Println("Usage: calculator <operation> <num1> <num2>")
		fmt.Println("Operations: add, subtract, multiply, divide")
		os.Exit(1)
	}

	operation := os.Args[1]
	num1, err1 := strconv.Atoi(os.Args[2])
	num2, err2 := strconv.Atoi(os.Args[3])

	if err1 != nil || err2 != nil {
		fmt.Println("Error: Arguments must be integers")
		os.Exit(1)
	}

	calc := &Calculator{}
	var result int

	switch operation {
	case "add":
		result = calc.Add(num1, num2)
	case "subtract":
		result = calc.Subtract(num1, num2)
	case "multiply":
		result = calc.Multiply(num1, num2)
	case "divide":
		result = calc.Divide(num1, num2)
	default:
		fmt.Println("Error: Invalid operation")
		os.Exit(1)
	}

	fmt.Printf("Result: %d\n", result)
}
```

## 步骤 1：初始化 Git 仓库并提交原始代码

```bash
# 进入示例项目目录
cd calculator

# 初始化 Git 仓库
git init

# 添加所有文件
git add .

# 提交原始版本
git commit -m "Initial commit with basic calculator functionality"

# 创建 main 分支（作为稳定分支）
git branch -M main
```

## 步骤 2：创建新分支并添加新功能

```bash
# 创建并切换到新分支
git checkout -b feature/power-function

# 在编辑器中修改代码，添加 Power 功能
```

修改后的代码（添加了 Power 方法并更新了 main 函数）：

```go
package main

import (
	"fmt"
	"math"
	"os"
	"strconv"
)

// Calculator provides basic arithmetic operations
type Calculator struct{}

// Add returns the sum of two numbers
func (c *Calculator) Add(a, b int) int {
	return a + b
}

// Subtract returns the difference of two numbers
func (c *Calculator) Subtract(a, b int) int {
	return a - b
}

// Multiply returns the product of two numbers
func (c *Calculator) Multiply(a, b int) int {
	return a * b
}

// Divide returns the quotient of two numbers
func (c *Calculator) Divide(a, b int) int {
	if b == 0 {
		fmt.Println("Error: Division by zero")
		return 0
	}
	return a / b
}

// Power returns a raised to the power of b
func (c *Calculator) Power(a, b int) int {
	return int(math.Pow(float64(a), float64(b)))
}

func main() {
	if len(os.Args) != 4 {
		fmt.Println("Usage: calculator <operation> <num1> <num2>")
		fmt.Println("Operations: add, subtract, multiply, divide, power")
		os.Exit(1)
	}

	operation := os.Args[1]
	num1, err1 := strconv.Atoi(os.Args[2])
	num2, err2 := strconv.Atoi(os.Args[3])

	if err1 != nil || err2 != nil {
		fmt.Println("Error: Arguments must be integers")
		os.Exit(1)
	}

	calc := &Calculator{}
	var result int

	switch operation {
	case "add":
		result = calc.Add(num1, num2)
	case "subtract":
		result = calc.Subtract(num1, num2)
	case "multiply":
		result = calc.Multiply(num1, num2)
	case "divide":
		result = calc.Divide(num1, num2)
	case "power":
		result = calc.Power(num1, num2)
	default:
		fmt.Println("Error: Invalid operation")
		os.Exit(1)
	}

	fmt.Printf("Result: %d\n", result)
}
```
提交新功能：

```bash
# 提交更改
git add .
git commit -m "Add power function to calculator"
```

## 步骤 3：初始化 goat 配置

```bash
# 初始化 goat 配置
goat init --old main --new feature/power-function --app-name "calculator" --granularity patch
```

这将在项目的根目录中生成一个 `goat.yaml` 配置文件，内容类似于：

```yaml
# Goat configuration goat.yaml
#
# This file is generated by goat.
# Please do modify when you know what you are doing.
# Every time the field is changed, please rerun "goat patch" to update the tracking results.
#
## App name
appName: calculator

## App version
appVersion: 1.0.0

## Old branch name (for comparison base)
oldBranch: main

## New branch name (for comparison target)
newBranch: feature/power-function

## Granularity ([line, patch, scope, func], default: patch)
granularity: patch

# ... 其他设置
```

## 步骤 4：运行 goat track 命令插入跟踪代码

```bash
# 运行 goat track 命令
goat track
```

命令输出示例：

```
[2025/04/23 22:17:28] INFO: Start to run track command
[2025/04/23 22:17:28] INFO: Track applied successfully with 2 tracking points
[2025/04/23 22:17:28] INFO: ----------------------------------------------------------
[2025/04/23 22:17:28] INFO: ✅ Track completed successfully!
```

## 步骤 5：检查插入的跟踪代码

运行 goat track 后，跟踪代码将自动插入到代码中。检查修改后的文件：

```bash
# 检查更改
git diff
```

输出示例（可以看到 goat 插入的跟踪代码）：

```diff
diff --git a/main.go b/main.go
index 041bd3c..96519bb 100644
--- a/main.go
+++ b/main.go
@@ -6,6 +6,7 @@ import (
 	"os"
 	"os/signal"
 	"strconv"
+	goat "calculator/goat"
 )

 // Calculator provides basic arithmetic operations
@@ -37,10 +38,18 @@ func (c *Calculator) Divide(a, b int) int {

 // Power returns a raised to the power of b
 func (c *Calculator) Power(a, b int) int {
+	// +goat:generate
+	// +goat:tips: do not edit the block between the +goat comments
+	goat.Track(goat.TRACK_ID_1)
+	// +goat:end
 	return int(math.Pow(float64(a), float64(b)))
 }

 func main() {
+	// +goat:main
+	// +goat:tips: do not edit the block between the +goat comments
+	goat.ServeHTTP(goat.COMPONENT_0)
+	// +goat:end
 	if len(os.Args) != 4 {
 		fmt.Println("Usage: calculator <operation> <num1> <num2>")
 		fmt.Println("Operations: add, subtract, multiply, divide")
@@ -69,6 +78,10 @@ func main() {
 	case "divide":
 		result = calc.Divide(num1, num2)
 	case "power":
+		// +goat:generate
+		// +goat:tips: do not edit the block between the +goat comments
+		goat.Track(goat.TRACK_ID_2)
+		// +goat:end
 		result = calc.Power(num1, num2)
 	default:
 		fmt.Println("Error: Invalid operation")

```

```bash
  # 查看修改后的代码
  cat main.go
```

修改后的 main.go：

```go
package main

import (
	"fmt"
	"math"
	"os"
	"os/signal"
	"strconv"
	goat "calculator/goat"
)

// Calculator provides basic arithmetic operations
type Calculator struct{}

// Add returns the sum of two numbers
func (c *Calculator) Add(a, b int) int {
	return a + b
}

// Subtract returns the difference of two numbers
func (c *Calculator) Subtract(a, b int) int {
	return a - b
}

// Multiply returns the product of two numbers
func (c *Calculator) Multiply(a, b int) int {
	return a * b
}

// Divide returns the quotient of two numbers
func (c *Calculator) Divide(a, b int) int {
	if b == 0 {
		fmt.Println("Error: Division by zero")
		return 0
	}
	return a / b
}

// Power returns a raised to the power of b
func (c *Calculator) Power(a, b int) int {
	// +goat:generate
	// +goat:tips: do not edit the block between the +goat comments
	goat.Track(goat.TRACK_ID_1)
	// +goat:end
	return int(math.Pow(float64(a), float64(b)))
}

func main() {
	// +goat:main
	// +goat:tips: do not edit the block between the +goat comments
	goat.ServeHTTP(goat.COMPONENT_0)
	// +goat:end
	if len(os.Args) != 4 {
		fmt.Println("Usage: calculator <operation> <num1> <num2>")
		fmt.Println("Operations: add, subtract, multiply, divide")
		os.Exit(1)
	}

	operation := os.Args[1]
	num1, err1 := strconv.Atoi(os.Args[2])
	num2, err2 := strconv.Atoi(os.Args[3])

	if err1 != nil || err2 != nil {
		fmt.Println("Error: Arguments must be integers")
		os.Exit(1)
	}

	calc := &Calculator{}
	var result int

	switch operation {
	case "add":
		result = calc.Add(num1, num2)
	case "subtract":
		result = calc.Subtract(num1, num2)
	case "multiply":
		result = calc.Multiply(num1, num2)
	case "divide":
		result = calc.Divide(num1, num2)
	case "power":
		// +goat:generate
		// +goat:tips: do not edit the block between the +goat comments
		goat.Track(goat.TRACK_ID_2)
		// +goat:end
		result = calc.Power(num1, num2)
	default:
		fmt.Println("Error: Invalid operation")
	}

	fmt.Printf("Result: %d\n", result)
	fmt.Println("Click http://localhost:57005/metrics to see the metrics")
	fmt.Println("Ctrl+C to stop the calculator")
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt)
	<-sigChan
	fmt.Println("Calculator stopped")
}

```


```bash
# 查看 goat/goat_generated.go
cat goat/goat_generated.go
```
goat/goat_generated.go 的内容如下：

```go
// +goat: generated by increment tracking package, do not edit
package goat

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"sort"
	"strconv"
	"strings"
)

// application version
const VERSION = "1.0.0"
// application name
const NAME = "calculator"
// track ID type
type trackId = int
// track ID values
const (
	// track ID start value
	TRACK_ID_START = iota
	TRACK_ID_1
	TRACK_ID_2
	// ...
	// track ID end value
	TRACK_ID_END
)

// track ID names
var TrackIdNames [TRACK_ID_END]string

// track ID status record - use slice instead of map to improve performance
var trackIdStatus [TRACK_ID_END]uint32

// initialize track IDs
func init() {
	for i := 1; i < TRACK_ID_END; i++ {
		TrackIdNames[i] = fmt.Sprintf("TRACK_ID_%d", i)
	}
}

// Track track function
func Track(id trackId) {
	if id > 0 && id < TRACK_ID_END {
		trackIdStatus[id] = 1
	}
}

// Component type
type Component = int

// Component IDs
const (
	_           = iota - 1
	COMPONENT_0 // 0
	// ...
)

// Components slice
var components = []Component{
	COMPONENT_0,
	// ...
}
// Component names
var componentNames = []string{
	COMPONENT_0: ".",
	// ...
}
// Component names map
var componentNamesMap = map[string]Component{
	".": COMPONENT_0,
	// ...
}
// GetComponentName get component name
func GetComponentName(component Component) string {
	return componentNames[component]
}

// Track IDs for component 0
var COMPONENT_0_TRACK_IDS = []trackId{
	TRACK_ID_1,
	TRACK_ID_2,
	// ...
}

// Component to track ID mapping
var COMPONENT_TRACK_IDS = map[Component][]trackId{
	COMPONENT_0: COMPONENT_0_TRACK_IDS,
	// ...
}

// Item struct
type Item struct {
	// track ID
	ID int `json:"id"`
	// track name
	Name string `json:"name"`
	// track count
	Count uint32 `json:"count"`
}

// Items slice
type Items []Item

// Metrics struct
type Metrics struct {
	// total track count
	Total       int    `json:"total"`
	// covered track count
	Covered     int    `json:"covered"`
	// covered rate
	CoveredRate int    `json:"coveredRate"`
	// track items
	Items       Items  `json:"items"`
}

// ComponentResult struct
type ComponentResult struct {
	// component
	ID Component `json:"id"`
	// component name
	Name string `json:"name"`
	// metrics
	Metrics   Metrics   `json:"metrics"`
}
// Results struct
type Results struct {
	// name
	Name string `json:"name"`
	// version
	Version string `json:"version"`
	// results
	Results []ComponentResult `json:"results"`
}
// ServeHTTP start HTTP service
func ServeHTTP(component Component) {
	go func() {
		system := http.NewServeMux()
		system.HandleFunc("/metrics", metricsHandler)
  		// DEAD in hexadecimal is 57005 in decimal
		port := "57005"
		if os.Getenv("GOAT_PORT") != "" {
			port = os.Getenv("GOAT_PORT")
		}
		expose := os.Getenv("GOAT_METRICS_IP")
		if expose == "" {
			expose = "127.0.0.1"
		}
		addr := fmt.Sprintf("%s:%s", expose, port)
		log.Printf("Goat track service started: http://%s\n", addr)
		// Tips how to use
		log.Printf("Goat track all components: http://%s/track\n", addr)
		log.Printf("Goat track component: http://%s/track?component=COMPONENT_ID\n", addr)
		log.Printf("Goat track components: http://%s/track?component=COMPONENT_ID,COMPONENT_ID2\n", addr)
		log.Printf("Goat track order by count asc: http://%s/track?component=COMPONENT_ID&order=0\n", addr)
		log.Printf("Goat track order by count desc: http://%s/track?component=COMPONENT_ID&order=1\n", addr)
		log.Printf("Goat track order by id asc: http://%s/track?component=COMPONENT_ID&order=2\n", addr)
		log.Printf("Goat track order by id desc: http://%s/track?component=COMPONENT_ID&order=3\n", addr)
		log.Fatal(http.ListenAndServe(addr, system))
	}()
}

// metricsHandler track ID status processing function
func metricsHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	// invalid order:
	// order=0: count asc (default)
	// order=1: count desc
	// order=2: id asc
	// order=3: id desc
	orderStr := r.URL.Query().Get("order")
	order, err := strconv.Atoi(orderStr)
	if err != nil || order < 0 || order > 3 {
		order = 0
	}
	cms := components
	componentStr := r.URL.Query().Get("component")
	if componentStr != "" {
		componentSlice := strings.Split(componentStr, ",")
		cms = make([]Component, 0, len(componentSlice))
		for _, componentStr := range componentSlice {
			componentIdx, ok := componentNamesMap[componentStr]
			if !ok {
				// check if it is a number
				componentIdx, err := strconv.Atoi(componentStr)
				if err != nil || componentIdx < 0 || componentIdx >= len(components) {
					http.Error(w, "invalid component", http.StatusBadRequest)
					return
				}
				cms = append(cms, Component(componentIdx))
				continue
			}
			cms = append(cms, componentIdx)
		}
	}

	results := make([]ComponentResult, 0, len(cms))
	for _, component := range cms {
		covered := 0
		componentTrackIds := COMPONENT_TRACK_IDS[component]
		items := make(Items, 0, len(componentTrackIds))
		for _, id := range componentTrackIds {
			count := trackIdStatus[id]
			items = append(items, Item{ID: id, Name: TrackIdNames[id], Count: count})
			if count > 0 {
				covered++
			}
		}

		switch order {
		case 0:
			sort.Slice(items, func(i, j int) bool {
				return items[i].Count < items[j].Count
			})
		case 1:
			sort.Slice(items, func(i, j int) bool {
				return items[i].Count > items[j].Count
			})
		case 2:
			sort.Slice(items, func(i, j int) bool {
				return items[i].ID < items[j].ID
			})
		case 3:
			sort.Slice(items, func(i, j int) bool {
				return items[i].ID > items[j].ID
			})
		}
		coveredRate := 0
		if len(componentTrackIds) > 0 {
			coveredRate = covered * 100 / len(componentTrackIds)
		}
		results = append(results, ComponentResult{
			ID:      component,
			Name:    GetComponentName(component),
			Metrics: Metrics{Total: len(componentTrackIds), Covered: covered, CoveredRate: coveredRate, Items: items},
		})
	}
	// output JSON
	jsonData, _ := json.Marshal(Results{Name: NAME, Version: VERSION, Results: results})
	w.Write(jsonData)
}


```

## 步骤 6：构建和运行应用程序

编译并运行程序：

```bash
# 编译程序
go build -o calculator

# 运行程序计算 2 的 3 次方
./calculator power 2 3
```

输出示例：

```
Result: 8
Click http://localhost:57005/metrics to see the metrics
Ctrl+C to stop the calculator
```

## 步骤 7：查看跟踪数据

当应用程序运行时，goat 会自动启动一个 HTTP 服务（默认端口 57005）来显示数据点的覆盖情况：

```bash
# 使用 curl 查询数据点状态
curl http://localhost:57005/metrics | jq
```

输出示例：

```json
{
  "name": "calculator",
  "version": "1.0.0",
  "results": [
    {
      "id": 0,
      "name": ".",
      "metrics": {
        "total": 2,
        "covered": 2,
        "coveredRate": 100,
        "items": [
          {
            "id": 1,
            "name": "TRACK_ID_1",
            "count": 1
          },
          {
            "id": 2,
            "name": "TRACK_ID_2",
            "count": 1
          }
        ]
      }
    }
  ]
}
```

## 总结

通过本示例，我们演示了如何使用 `goat track` 命令实现以下功能：

1. 自动识别代码变更（新增的 Power 功能）
2. 自动插入跟踪代码
3. 在运行时收集埋点执行情况的数据
4. 通过 HTTP 接口查看埋点的覆盖情况

这种跟踪方法在灰度发布中非常有用，可以帮助开发人员确认新功能在生产环境中是否被正确调用和执行。
