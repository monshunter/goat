package increment

import (
	"bytes"
	"fmt"

	"github.com/monshunter/goat/pkg/config"
)

const Template = `// +goat: generated by increment tracking package, do not edit
package {{.PackageName}}

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	{{ if .Race -}}
	"sync/atomic"
	{{ end -}}
	"sort"
	"strconv"
	"strings"
)

// application version
const VERSION = "{{.Version}}"
// application name
const NAME = "{{.Name}}"
// track ID type
type trackId = int
// track ID values
const (
	// track ID start value
	TRACK_ID_START = iota{{range .TrackIds}}
	TRACK_ID_{{.}}{{end}}
	// ...
	// track ID end value
	TRACK_ID_END
)

// track ID names
var TrackIdNames [TRACK_ID_END]string

// track ID status record - use slice instead of map to improve performance
var trackIdStatus [TRACK_ID_END]uint32

// initialize track IDs
func init() {
	for i := 1; i < TRACK_ID_END; i++ {
		TrackIdNames[i] = fmt.Sprintf("TRACK_ID_%d", i)
	}
}

// Track track function
func Track(id trackId) {
	if id > 0 && id < TRACK_ID_END {
		{{ if .Race -}}
		   {{ if eq .DataType 1 -}}
			atomic.StoreUint32(&trackIdStatus[id], 1)
			{{- else -}}
			atomic.AddUint32(&trackIdStatus[id], 1)
			{{- end -}}
		{{- else -}}
			{{ if eq .DataType 1 -}}
			trackIdStatus[id] = 1
			{{- else -}}
			trackIdStatus[id]++
			{{- end -}}
		{{- end }}
	}
}

// Component type
type Component = int

// Component IDs
const (
	_           = iota - 1 {{range .Components}}
	COMPONENT_{{ .ID }} // {{ .ID }}{{end}}
	// ...
)

// Components slice
var components = []Component{ {{- range .Components}}
	COMPONENT_{{ .ID }},{{end}}
	// ...
}
// Component names
var componentNames = []string{ {{- range .Components}}
	COMPONENT_{{ .ID }}: "{{ .Name }}",{{end}}
	// ...
}
// Component names map
var componentNamesMap = map[string]Component{ {{- range .Components}}
	"{{ .Name }}": COMPONENT_{{ .ID }},{{end}}
	// ...
}
// GetComponentName get component name
func GetComponentName(component Component) string {
	return componentNames[component]
}
{{range .Components}}
// Track IDs for component {{ .ID }}
var COMPONENT_{{ .ID }}_TRACK_IDS = []trackId{ {{- range .TrackIds}}
	TRACK_ID_{{.}},{{end}}
	// ...
}{{end}}

// Component to track ID mapping
var COMPONENT_TRACK_IDS = map[Component][]trackId{ {{- range .Components}}
	COMPONENT_{{ .ID }}: COMPONENT_{{ .ID }}_TRACK_IDS,{{end}}
	// ...
}

// Item struct
type Item struct {
	// track ID
	ID int ` + "`json:\"id\"`" + `
	// track name
	Name string ` + "`json:\"name\"`" + `
	// track count
	Count uint32 ` + "`json:\"count\"`" + `
}

// Items slice
type Items []Item

// Metrics struct
type Metrics struct {
	// total track count
	Total       int    ` + "`json:\"total\"`" + `
	// covered track count
	Covered     int    ` + "`json:\"covered\"`" + `
	// covered rate
	CoveredRate int    ` + "`json:\"coveredRate\"`" + `
	// track items
	Items       Items  ` + "`json:\"items\"`" + `
}

// ComponentResult struct
type ComponentResult struct {
	// component
	ID Component ` + "`json:\"id\"`" + `
	// component name
	Name string ` + "`json:\"name\"`" + `
	// metrics
	Metrics   Metrics   ` + "`json:\"metrics\"`" + `
}
// Results struct
type Results struct {
	// name
	Name string ` + "`json:\"name\"`" + `
	// version
	Version string ` + "`json:\"version\"`" + `
	// results
	Results []ComponentResult ` + "`json:\"results\"`" + `
}
// ServeHTTP start HTTP service
func ServeHTTP(component Component) {
	go func() {
		system := http.NewServeMux()
		system.HandleFunc("/metrics", metricsHandler)
  		// DEAD in hexadecimal is 57005 in decimal
		port := "57005"
		if os.Getenv("GOAT_PORT") != "" {
			port = os.Getenv("GOAT_PORT")
		}
		expose := os.Getenv("GOAT_METRICS_IP")
		if expose == "" {
			expose = "127.0.0.1"
		}
		addr := fmt.Sprintf("%s:%s", expose, port)
		log.Printf("Goat track service started: http://%s\n", addr)
		// Tips how to use
		log.Printf("Goat track all components: http://%s/metrics\n", addr)
		log.Printf("Goat track component: http://%s/metrics?component=COMPONENT_ID\n", addr)
		log.Printf("Goat track components: http://%s/metrics?component=COMPONENT_ID,COMPONENT_ID2\n", addr)
		log.Printf("Goat track order by count asc: http://%s/metrics?component=COMPONENT_ID&order=0\n", addr)
		log.Printf("Goat track order by count desc: http://%s/metrics?component=COMPONENT_ID&order=1\n", addr)
		log.Printf("Goat track order by id asc: http://%s/metrics?component=COMPONENT_ID&order=2\n", addr)
		log.Printf("Goat track order by id desc: http://%s/metrics?component=COMPONENT_ID&order=3\n", addr)
		log.Fatal(http.ListenAndServe(addr, system))
	}()
}

// metricsHandler track ID status processing function
func metricsHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	// invalid order:
	// order=0: count asc (default)
	// order=1: count desc
	// order=2: id asc
	// order=3: id desc
	orderStr := r.URL.Query().Get("order")
	order, err := strconv.Atoi(orderStr)
	if err != nil || order < 0 || order > 3 {
		order = 0
	}
	cms := components
	componentStr := r.URL.Query().Get("component")
	if componentStr != "" {
		componentSlice := strings.Split(componentStr, ",")
		cms = make([]Component, 0, len(componentSlice))
		for _, componentStr := range componentSlice {
			componentIdx, ok := componentNamesMap[componentStr]
			if !ok {
				// check if it is a number
				componentIdx, err := strconv.Atoi(componentStr)
				if err != nil || componentIdx < 0 || componentIdx >= len(components) {
					http.Error(w, "invalid component", http.StatusBadRequest)
					return
				}
				cms = append(cms, Component(componentIdx))
				continue
			}
			cms = append(cms, componentIdx)
		}
	}

	results := make([]ComponentResult, 0, len(cms))
	for _, component := range cms {
		covered := 0
		componentTrackIds := COMPONENT_TRACK_IDS[component]
		items := make(Items, 0, len(componentTrackIds))
		for _, id := range componentTrackIds {
			{{ if .Race -}}
			count := atomic.LoadUint32(&trackIdStatus[id])
			{{- else -}}
			count := trackIdStatus[id]
			{{- end }}
			items = append(items, Item{ID: id, Name: TrackIdNames[id], Count: count})
			if count > 0 {
				covered++
			}
		}

		switch order {
		case 0:
			sort.Slice(items, func(i, j int) bool {
				return items[i].Count < items[j].Count
			})
		case 1:
			sort.Slice(items, func(i, j int) bool {
				return items[i].Count > items[j].Count
			})
		case 2:
			sort.Slice(items, func(i, j int) bool {
				return items[i].ID < items[j].ID
			})
		case 3:
			sort.Slice(items, func(i, j int) bool {
				return items[i].ID > items[j].ID
			})
		}
		coveredRate := 0
		if len(componentTrackIds) > 0 {
			coveredRate = covered * 100 / len(componentTrackIds)
		}
		results = append(results, ComponentResult{
			ID:      component,
			Name:    GetComponentName(component),
			Metrics: Metrics{Total: len(componentTrackIds), Covered: covered, CoveredRate: coveredRate, Items: items},
		})
	}
	// output JSON
	jsonData, _ := json.Marshal(Results{Name: NAME, Version: VERSION, Results: results})
	w.Write(jsonData)
}
`

const TrackImportPathPlaceHolder = `github.com/monshunter/goat/goat`
const TrackStmtPlaceHolder = `goat.Track(TRACK_ID)`

func GetMainEntryInsertData(ident string, componentID int) []string {
	return []string{
		config.TrackMainEntryComment,
		config.TrackTipsComment,
		fmt.Sprintf("%s.ServeHTTP(%s.COMPONENT_%d)", ident, ident, componentID),
		config.TrackEndComment,
	}
}

func GetPackageInsertStmts() []string {
	return []string{
		config.TrackGenerateComment,
		config.TrackTipsComment,
		TrackStmtPlaceHolder,
		config.TrackEndComment,
	}
}

func GetPackageInsertDataString() string {
	buf := bytes.NewBuffer(nil)
	for _, line := range GetPackageInsertStmts() {
		buf.WriteString(line)
		buf.WriteString("\n")
	}
	return buf.String()
}

func IncreamentReplaceStmt(ident string, start int) func(older string) (newer string) {
	return func(older string) (newer string) {
		newer = fmt.Sprintf(`%s.Track(%s.TRACK_ID_%d)`, ident, ident, start)
		start++
		return
	}
}

func IncreamentReplaceImport(alias string, importPath string) func(older string) (newer string) {
	return func(older string) (newer string) {
		newer = fmt.Sprintf(`%s "%s"`, alias, importPath)
		return
	}
}
