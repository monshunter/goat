package increament

const Template = `// +goat: generated by increament tracking package, do not edit
package {{.PackageName}}

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	{{ if .Race -}}
	"sync/atomic"
	{{ end -}}
)
// application version
const VERSION = "{{.Version}}"
// application name
const NAME = "{{.Name}}"
// track ID type
type trackId = int
// track ID values
const (
	// track ID start value
	TRACK_ID_START = iota{{range .TrackIds}}
	TRACK_ID_{{.}}{{end}}
	// ...
	// track ID end value
	TRACK_ID_END
)

// track ID names
var TrackIdNames []string

// track ID status record - use slice instead of map to improve performance
var trackIds []int32

// initialize track IDs
func init() {
	TrackIdNames = make([]string, TRACK_ID_END)
	for i := 1; i < TRACK_ID_END; i++ {
		TrackIdNames[i] = fmt.Sprintf("TRACK_ID_%d", i)
	}
	// initialize track ID status slice
	trackIds = make([]int32, TRACK_ID_END)
}

// Track track function
func Track(id trackId) {
	if id > 0 && id < TRACK_ID_END {
		{{ if .Race -}}
		atomic.StoreInt32(&trackIds[id], 1)
		{{- else -}}
		trackIds[id] = 1
		{{- end }}
	}
}

// Component type
type Component = int

// Component IDs
const (
	_           = iota{{range .Components}}
	COMPONENT_{{ .ID }} // {{ .ID }}{{end}}
	// ...
)

// Components slice
var components = []Component{ {{- range .Components}}
	COMPONENT_{{ .ID }},{{end}}
	// ...
}
// Component names
var componentNames = []string{ {{- range .Components}}
	COMPONENT_{{ .ID }}: "{{ .Name }}",{{end}}
	// ...
}
// Component names map
var componentNamesMap = map[string]Component{ {{- range .Components}}
	"{{ .Name }}": COMPONENT_{{ .ID }},{{end}}
	// ...
}
// GetComponentName get component name
func GetComponentName(component Component) string {
	return componentNames[component]
}
{{range .Components}}
// Track IDs for component {{ .ID }}
var COMPONENT_{{ .ID }}_TRACK_IDS = []trackId{ {{- range .TrackIds}}
	TRACK_ID_{{.}},{{end}}
	// ...
}{{end}}

// Component to track ID mapping
var COMPONENT_TRACK_IDS = map[Component][]trackId{ {{- range .Components}}
	COMPONENT_{{ .ID }}: COMPONENT_{{ .ID }}_TRACK_IDS,{{end}}
	// ...
}
// Metrics struct
type Metrics struct {
	Total   int             ` + "`json:\"total\"`" + `
	Covered int             ` + "`json:\"covered\"`" + `
	Metrics map[string]bool ` + "`json:\"metrics\"`" + `
}
// ComponentResult struct
type ComponentResult struct {
	Component Component ` + "`json:\"component\"`" + `
	Metrics   Metrics   ` + "`json:\"metrics\"`" + `
}
// Results struct
type Results struct {
	Results []ComponentResult ` + "`json:\"results\"`" + `
}
// ServeHTTP start HTTP service
func ServeHTTP(component Component) {
	go func() {
		system := http.NewServeMux()
		system.HandleFunc("/metrics", metricsHandler)
  		// DEAD in hexadecimal is 57005 in decimal
		port := "57005"
		if os.Getenv("GOAT_PORT") != "" {
			port = os.Getenv("GOAT_PORT")
		}
		addr := fmt.Sprintf("0.0.0.0:%s", port)
		fmt.Printf("Goat track service started: http://0.0.0.0%s\n", addr)
		log.Fatal(http.ListenAndServe(addr, system))
	}()
}

// metricsHandler track ID status processing function
func metricsHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	cms := components
	component := r.URL.Query().Get("component")
	if component != "" {
		componentIdx, ok := componentNamesMap[component]
		if !ok {
			http.Error(w, "invalid component", http.StatusBadRequest)
			return
		}
		cms = []Component{componentIdx}
	}

	results := make([]ComponentResult, 0, len(cms))
	for _, component := range cms {
		metrics := make(map[string]bool)
		covered := 0
		idxs := COMPONENT_TRACK_IDS[component]
		for _, id := range idxs {
			{{ if .Race -}}
			isTracked := atomic.LoadInt32(&trackIds[id]) == 1
			{{- else -}}
			isTracked := trackIds[id] == 1
			{{- end }}
			metrics[TrackIdNames[id]] = isTracked
			if isTracked {
				covered++
			}
		}
		results = append(results, ComponentResult{
			Component: component,
			Metrics:   Metrics{Total: len(idxs), Covered: covered, Metrics: metrics},
		})
	}
	// output JSON
	jsonData, _ := json.Marshal(Results{Results: results})
	w.Write(jsonData)
}
`
