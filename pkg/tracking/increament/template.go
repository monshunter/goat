package increament

import (
	"bytes"
	"fmt"

	"github.com/monshunter/goat/pkg/config"
)

const Template = `// +goat: generated by increament tracking package, do not edit
package {{.PackageName}}

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	{{ if .Race -}}
	"sync/atomic"
	{{ end -}}
	"sort"
)

// application version
const VERSION = "{{.Version}}"
// application name
const NAME = "{{.Name}}"
// track ID type
type trackId = int
// track ID values
const (
	// track ID start value
	TRACK_ID_START = iota{{range .TrackIds}}
	TRACK_ID_{{.}}{{end}}
	// ...
	// track ID end value
	TRACK_ID_END
)

// track ID names
var TrackIdNames [TRACK_ID_END]string

// track ID status record - use slice instead of map to improve performance
var trackIdStatus [TRACK_ID_END]uint32

// initialize track IDs
func init() {
	for i := 1; i < TRACK_ID_END; i++ {
		TrackIdNames[i] = fmt.Sprintf("TRACK_ID_%d", i)
	}
}

// Track track function
func Track(id trackId) {
	if id > 0 && id < TRACK_ID_END {
		{{ if .Race -}}
		   {{ if eq .DataType 1 -}}
			atomic.StoreUint32(&trackIdStatus[id], 1)
			{{- else -}}
			atomic.AndUint32(&trackIdStatus[id], 1)
			{{- end -}}
		{{- else -}}
			{{ if eq .DataType 1 -}}
			trackIdStatus[id] = 1
			{{- else -}}
			trackIdStatus[id]++
			{{- end -}}
		{{- end }}
	}
}

// Component type
type Component = int

// Component IDs
const (
	_           = iota - 1 {{range .Components}}
	COMPONENT_{{ .ID }} // {{ .ID }}{{end}}
	// ...
)

// Components slice
var components = []Component{ {{- range .Components}}
	COMPONENT_{{ .ID }},{{end}}
	// ...
}
// Component names
var componentNames = []string{ {{- range .Components}}
	COMPONENT_{{ .ID }}: "{{ .Name }}",{{end}}
	// ...
}
// Component names map
var componentNamesMap = map[string]Component{ {{- range .Components}}
	"{{ .Name }}": COMPONENT_{{ .ID }},{{end}}
	// ...
}
// GetComponentName get component name
func GetComponentName(component Component) string {
	return componentNames[component]
}
{{range .Components}}
// Track IDs for component {{ .ID }}
var COMPONENT_{{ .ID }}_TRACK_IDS = []trackId{ {{- range .TrackIds}}
	TRACK_ID_{{.}},{{end}}
	// ...
}{{end}}

// Component to track ID mapping
var COMPONENT_TRACK_IDS = map[Component][]trackId{ {{- range .Components}}
	COMPONENT_{{ .ID }}: COMPONENT_{{ .ID }}_TRACK_IDS,{{end}}
	// ...
}

// Item struct
type Item struct {
	// track ID
	ID int ` + "`json:\"id\"`" + `
	// track name
	Name string ` + "`json:\"name\"`" + `
	// track count
	Count uint32 ` + "`json:\"count\"`" + `
}

// Items slice
type Items []Item

// Metrics struct
type Metrics struct {
	// total track count
	Total       int    ` + "`json:\"total\"`" + `
	// covered track count
	Covered     int    ` + "`json:\"covered\"`" + `
	// covered rate
	CoveredRate int    ` + "`json:\"coveredRate\"`" + `
	// track items
	Items       Items  ` + "`json:\"items\"`" + `
}

// ComponentResult struct
type ComponentResult struct {
	// component
	ID Component ` + "`json:\"id\"`" + `
	// component name
	Name string ` + "`json:\"name\"`" + `
	// metrics
	Metrics   Metrics   ` + "`json:\"metrics\"`" + `
}
// Results struct
type Results struct {
	Results []ComponentResult ` + "`json:\"results\"`" + `
}
// ServeHTTP start HTTP service
func ServeHTTP(component Component) {
	go func() {
		system := http.NewServeMux()
		system.HandleFunc("/metrics", metricsHandler)
  		// DEAD in hexadecimal is 57005 in decimal
		port := "57005"
		if os.Getenv("GOAT_PORT") != "" {
			port = os.Getenv("GOAT_PORT")
		}
		expose := os.Getenv("GOAT_EXPOSE")
		if expose == "" {
			expose = "0.0.0.0"
		}
		addr := fmt.Sprintf("%s:%s", expose, port)
		log.Printf("Goat track service started: http://%s\n", addr)
		log.Fatal(http.ListenAndServe(addr, system))
	}()
}

// metricsHandler track ID status processing function
func metricsHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	cms := components
	component := r.URL.Query().Get("component")
	if component != "" {
		componentIdx, ok := componentNamesMap[component]
		if !ok {
			http.Error(w, "invalid component", http.StatusBadRequest)
			return
		}
		cms = []Component{componentIdx}
	}

	results := make([]ComponentResult, 0, len(cms))
	for _, component := range cms {
		covered := 0
		idxs := COMPONENT_TRACK_IDS[component]
		items := make(Items, 0, len(idxs))
		for _, id := range idxs {
			{{ if .Race -}}
			count := atomic.LoadUint32(&trackIdStatus[id])
			{{- else -}}
			count := trackIdStatus[id]
			{{- end }}
			items = append(items, Item{ID: id, Name: TrackIdNames[id], Count: count})
			if count > 0 {
				covered++
			}
		}

		sort.Slice(items, func(i, j int) bool {
			return items[i].Count < items[j].Count
		})

		results = append(results, ComponentResult{
			ID:      component,
			Name:    GetComponentName(component),
			Metrics: Metrics{Total: len(idxs), Covered: covered, CoveredRate: covered * 100 / len(idxs), Items: items},
		})
	}
	// output JSON
	jsonData, _ := json.Marshal(Results{Results: results})
	w.Write(jsonData)
}
`

const TrackImportPathPlaceHolder = `github.com/monshunter/goat/goat`
const TrackStmtPlaceHolder = `goat.Track(TRACK_ID)`

func GetMainEntryInsertData(ident string, componentID int) []string {
	return []string{
		config.TrackMainEntryComment,
		config.TrackTipsComment,
		fmt.Sprintf("%s.ServeHTTP(%s.COMPONENT_%d)", ident, ident, componentID),
		config.TrackEndComment,
	}
}

func GetPackageInsertData() []string {
	return []string{
		config.TrackGenerateComment,
		config.TrackTipsComment,
		TrackStmtPlaceHolder,
		config.TrackEndComment,
	}
}

func GetPackageInsertDataString() string {
	buf := bytes.NewBuffer(nil)
	for _, line := range GetPackageInsertData() {
		buf.WriteString(line)
		buf.WriteString("\n")
	}
	return buf.String()
}

func IncreamentReplaceStmt(ident string, start int) func(older string) (newer string) {
	return func(older string) (newer string) {
		newer = fmt.Sprintf(`%s.Track(%s.TRACK_ID_%d)`, ident, ident, start)
		start++
		return
	}
}

func IncreamentReplaceImport(alias string, importPath string) func(older string) (newer string) {
	return func(older string) (newer string) {
		newer = fmt.Sprintf(`%s "%s"`, alias, importPath)
		return
	}
}
