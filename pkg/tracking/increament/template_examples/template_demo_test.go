// +goat: generated by increament tracking package, do not edit
package increament_test

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"slices"

	"github.com/monshunter/goat/pkg/log"
)

// application version
const VERSION = "1.0.0"

// application name
const NAME = "example-app"

// track ID type
type trackId = int

// track ID values
const (
	// track ID start value
	TRACK_ID_START = iota
	TRACK_ID_1
	TRACK_ID_2
	TRACK_ID_3
	// ...
	// track ID end value
	TRACK_ID_END
)

// track ID names
var TrackIdNames [TRACK_ID_END]string

// track ID status record - use slice instead of map to improve performance
var trackIdStatus [TRACK_ID_END]uint

// var trackIdStatus [TRACK_ID_END]uint8

// initialize track IDs
func init() {
	for i := 1; i < TRACK_ID_END; i++ {
		TrackIdNames[i] = fmt.Sprintf("TRACK_ID_%d", i)
	}
}

// Track track function
func Track(id trackId) {
	if id > 0 && id < TRACK_ID_END {
		trackIdStatus[id] = 1

		// trackIds[id]++
	}
}

// Component type
type Component = int

// Component IDs
const (
	_           = iota - 1
	COMPONENT_0 // 0
	COMPONENT_1 // 1
	COMPONENT_2 // 2
	COMPONENT_3 // 3
	COMPONENT_4 // 4
	COMPONENT_5 // 5
	// ...
)

// Components slice
var components = []Component{
	COMPONENT_0,
	COMPONENT_1,
	COMPONENT_2,
	COMPONENT_3,
	COMPONENT_4,
	COMPONENT_5,
	// ...
}

// Component names
var componentNames = []string{
	COMPONENT_0: "cmd/blockfycodes",
	COMPONENT_1: "cmd/findmain",
	COMPONENT_2: "cmd/getblockscopes",
	COMPONENT_3: "cmd/getcomments",
	COMPONENT_4: "cmd/testfirstclassfunc",
	COMPONENT_5: "cmd/topomain",
	// ...
}

// Component names map
var componentNamesMap = map[string]Component{
	"cmd/blockfycodes":       COMPONENT_0,
	"cmd/findmain":           COMPONENT_1,
	"cmd/getblockscopes":     COMPONENT_2,
	"cmd/getcomments":        COMPONENT_3,
	"cmd/testfirstclassfunc": COMPONENT_4,
	"cmd/topomain":           COMPONENT_5,
	// ...
}

// GetComponentName get component name
func GetComponentName(component Component) string {
	return componentNames[component]
}

// Track IDs for component 0
var COMPONENT_0_TRACK_IDS = []trackId{
	// ...
}

// Track IDs for component 1
var COMPONENT_1_TRACK_IDS = []trackId{
	// ...
}

// Track IDs for component 2
var COMPONENT_2_TRACK_IDS = []trackId{
	// ...
}

// Track IDs for component 3
var COMPONENT_3_TRACK_IDS = []trackId{
	// ...
}

// Track IDs for component 4
var COMPONENT_4_TRACK_IDS = []trackId{
	TRACK_ID_1,
	TRACK_ID_2,
	TRACK_ID_3,
	// ...
}

// Track IDs for component 5
var COMPONENT_5_TRACK_IDS = []trackId{
	// ...
}

// Component to track ID mapping
var COMPONENT_TRACK_IDS = map[Component][]trackId{
	COMPONENT_0: COMPONENT_0_TRACK_IDS,
	COMPONENT_1: COMPONENT_1_TRACK_IDS,
	COMPONENT_2: COMPONENT_2_TRACK_IDS,
	COMPONENT_3: COMPONENT_3_TRACK_IDS,
	COMPONENT_4: COMPONENT_4_TRACK_IDS,
	COMPONENT_5: COMPONENT_5_TRACK_IDS,
	// ...
}

// Item struct
type Item struct {
	// track ID
	ID int `json:"id"`
	// track name
	Name string `json:"name"`
	// track count
	Count int `json:"count"`
}

// Items slice
type Items []Item

// Metrics struct
type Metrics struct {
	// total track count
	Total int `json:"total"`
	// covered track count
	Covered int `json:"covered"`
	// covered rate
	CoveredRate int `json:"coveredRate"` // 0-100
	// track items
	Items Items `json:"items"`
}

// ComponentResult struct
type ComponentResult struct {
	// component ID
	ID Component `json:"id"`
	// component name
	Name string `json:"name"`
	// metrics
	Metrics Metrics `json:"metrics"`
}

// Results struct
type Results struct {
	Results []ComponentResult `json:"results"`
}

// ServeHTTP start HTTP service
func ServeHTTP(component Component) {
	go func() {
		system := http.NewServeMux()
		system.HandleFunc("/metrics", metricsHandler)
		// DEAD in hexadecimal is 57005 in decimal
		port := "57005"
		if os.Getenv("GOAT_PORT") != "" {
			port = os.Getenv("GOAT_PORT")
		}
		expose := os.Getenv("GOAT_EXPOSE")
		if expose == "" {
			expose = "0.0.0.0"
		}
		addr := fmt.Sprintf("%s:%s", expose, port)
		log.Infof("Goat track service started: http://%s\n", addr)
		log.Fatal(http.ListenAndServe(addr, system))
	}()
}

// metricsHandler track ID status processing function
func metricsHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	cms := components
	component := r.URL.Query().Get("component")
	if component != "" {
		componentIdx, ok := componentNamesMap[component]
		if !ok {
			http.Error(w, "invalid component", http.StatusBadRequest)
			return
		}
		cms = []Component{componentIdx}
	}

	results := make([]ComponentResult, 0, len(cms))
	for _, component := range cms {
		covered := 0
		idxs := COMPONENT_TRACK_IDS[component]
		items := make(Items, 0, len(idxs))
		for _, id := range idxs {
			count := int(trackIdStatus[id])
			items = append(items, Item{ID: id, Name: TrackIdNames[id], Count: count})
			if count > 0 {
				covered++
			}
		}
		slices.SortFunc(items, func(a, b Item) int {
			return a.Count - b.Count
		})
		results = append(results, ComponentResult{
			ID:      component,
			Name:    GetComponentName(component),
			Metrics: Metrics{Total: len(idxs), Covered: covered, CoveredRate: covered * 100 / len(idxs), Items: items},
		})
	}
	// output JSON
	jsonData, _ := json.Marshal(Results{Results: results})
	w.Write(jsonData)
}
